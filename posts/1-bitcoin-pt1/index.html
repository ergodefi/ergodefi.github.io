<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Bitcoin transaction: a deep dive | Part 1 | Michael Y. Han</title>
<meta name="keywords" content="" />
<meta name="description" content="Overview When you buy or sell bitcoin, the underlying transaction (i.e. deposit or withdraw) will be recorded and stored permanently on the Bitcoin Network, creating a massive decentralized ledger. This was one of the cornerstone concepts of Bitcoin.
The bitcoin transaction, and the cryptography behind it, is one of the most important and elegant part of Bitcoin. It also forms the foundation for other blockchain platforms, including Ethereum and Solana. So the way I see it, becoming intimately familiar with the inner workings of the bitcoin tranaction is a pre-requisite to getting into the defi space as an engineer or developer.">
<meta name="author" content="">
<link rel="canonical" href="https://ergodefi.github.io/posts/1-bitcoin-pt1/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css" integrity="sha256-yIlj/i15RiAA/Q&#43;xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://ergodefi.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://ergodefi.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://ergodefi.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://ergodefi.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://ergodefi.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Bitcoin transaction: a deep dive | Part 1" />
<meta property="og:description" content="Overview When you buy or sell bitcoin, the underlying transaction (i.e. deposit or withdraw) will be recorded and stored permanently on the Bitcoin Network, creating a massive decentralized ledger. This was one of the cornerstone concepts of Bitcoin.
The bitcoin transaction, and the cryptography behind it, is one of the most important and elegant part of Bitcoin. It also forms the foundation for other blockchain platforms, including Ethereum and Solana. So the way I see it, becoming intimately familiar with the inner workings of the bitcoin tranaction is a pre-requisite to getting into the defi space as an engineer or developer." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ergodefi.github.io/posts/1-bitcoin-pt1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-02-12T17:51:29-08:00" />
<meta property="article:modified_time" content="2022-02-12T17:51:29-08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Bitcoin transaction: a deep dive | Part 1"/>
<meta name="twitter:description" content="Overview When you buy or sell bitcoin, the underlying transaction (i.e. deposit or withdraw) will be recorded and stored permanently on the Bitcoin Network, creating a massive decentralized ledger. This was one of the cornerstone concepts of Bitcoin.
The bitcoin transaction, and the cryptography behind it, is one of the most important and elegant part of Bitcoin. It also forms the foundation for other blockchain platforms, including Ethereum and Solana. So the way I see it, becoming intimately familiar with the inner workings of the bitcoin tranaction is a pre-requisite to getting into the defi space as an engineer or developer."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://ergodefi.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Bitcoin transaction: a deep dive | Part 1",
      "item": "https://ergodefi.github.io/posts/1-bitcoin-pt1/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Bitcoin transaction: a deep dive | Part 1",
  "name": "Bitcoin transaction: a deep dive | Part 1",
  "description": "Overview When you buy or sell bitcoin, the underlying transaction (i.e. deposit or withdraw) will be recorded and stored permanently on the Bitcoin Network, creating a massive decentralized ledger. This was one of the cornerstone concepts of Bitcoin.\nThe bitcoin transaction, and the cryptography behind it, is one of the most important and elegant part of Bitcoin. It also forms the foundation for other blockchain platforms, including Ethereum and Solana. So the way I see it, becoming intimately familiar with the inner workings of the bitcoin tranaction is a pre-requisite to getting into the defi space as an engineer or developer.",
  "keywords": [
    
  ],
  "articleBody": "Overview When you buy or sell bitcoin, the underlying transaction (i.e. deposit or withdraw) will be recorded and stored permanently on the Bitcoin Network, creating a massive decentralized ledger. This was one of the cornerstone concepts of Bitcoin.\nThe bitcoin transaction, and the cryptography behind it, is one of the most important and elegant part of Bitcoin. It also forms the foundation for other blockchain platforms, including Ethereum and Solana. So the way I see it, becoming intimately familiar with the inner workings of the bitcoin tranaction is a pre-requisite to getting into the defi space as an engineer or developer.\nIn this multi-part series, I am going to do a deep dive into this topic. You will see that with a little bit of know-how and some basic computer programming knowledge, you can see exactly what goes on in a bitcoin transaction.\nWe are going to go through, step-by-step, the creation of a bitcoin transaction, from creating your own wallet and receiving bitcoins to sending them in a transfer and unlocking the value with a digital signature. Furthermore, I am going to show you programmatically in Python, so that you see the technical implementation of this as well.\nMost guides do not dive deep enough into the technical detals, so you end up only with superficial knowledge of the Bitcoin Protocol. To get that hands-on experience, we will use the Bitcoin Testnet to produce actual transactions (that you can verify on Block Explorer) and make everything replicable so that you can do the same.\nI hope you are excited, because this is going to be a fun ride!\nPart 1 - Keys and Addresses (the “Bank Accounts”) To create a bitcoin transaction, we first need accounts to hold the bitcoins. In Bitcoin, this is commonly known as a wallet, but it is really just a collection of private keys. With the private key, you generate a public key that serves as your account number. Anyone who wishes to transfer you funds can do so by sending money to this account.\nA private key is simply a string of randomly generated numbers that you hold, in private, which identifies you as the owner through the process of creating and signing digital signatures. We will cover digital signatures in Chapter 3.\nThe private key also generates the public key, but the reverse does not happen. This is known as a trap door function. As long as you, and only you, have possession of the private key, you can access the funds associated with the public key. In Bitcoin, the trap door function used is a form of Elliptic Curve Digital Signature Algorithm (ECDSA). We are not going to cover how ECDSA works as it is math heavy, but we are going to demonstrate how it works.\nWhen Bitcoin was first introduced, this was, in a nutshell, how it worked. A transaction sent to a public key is known as a Pay to Public Key (P2PK) transaction. The first bitcoin transaction was a P2PK transaction.\nSomewhere down the line, an improvement was made so that instead of giving out the public key, which is a massively long number, you give out a hash of the public key, a smaller number. A hashing function is a trap door function that takes the public key and creates the public key hash. This become known as a Pay to Public Key Hash (P2PKH) transaction. To date, P2PKH is the most common transaction on the Bitcoin Protocol. In the next chapter, we are going to generate a P2PKH transaction from scratch to show you how it all works.\n[P2SH section]\nIn the coding portion below, I will generate a private key, use ECDSA to generate a public key and the hashing function to generate a public key hash. I will then transfer some bitcoins, on the Testnet using a faucet tool, to this address so that we have some funds to play with.\nLet’s start!\nA note about coding There is a lot of math used in implementing Bitcoin, but you don’t need to fully understand them to understand Bitcoin. To make sure we can learn Bitcoin without being bogged down by the math, I created a helper file that has all of the needed algorithms and functions.\nMake sure you download it and run it before you follow along with the code below.\nSetup the helper.py file First, let’s import from helper.py. These are all data structures and functions that enable elliptical curve multiplication, the trapdoor function that generates the public key from the private key.\nfrom helper import Curve, Point, Generator, ec_addition, double_and_add Once we have the structures, we can create the “Bitcoin curve” also known as the secp256k1, a specific type of ellitpical curve set over a finite field. We can define some constants at this point, including the generator point (G) and the point at infinity.\nDon’t worry if you are confused at this point. There are lots of great articles written to help you understand ellptical curve cryptography and how it works.\n# secp256k1 ellptical curve constants - y^2 = x^3 + 7 (mod p) bitcoin_curve = Curve( p = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F, a = 0x0, b = 0x7, ) # generator point  G = Point( bitcoin_curve, x = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798, y = 0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8, ) bitcoin_gen = Generator( G = G, n = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141, ) # point at infinity  INF = Point(None, None, None) Because we are working with points on a finite field, the concept of addition and multiplication are also different. When addition or multiplication takes the value outside of the finite field, the value “wraps around” so that it would fall into this range.\nIf you have ever played classic games incluidng Asteriod or Donkey Kong, when you go out of bounds on one side of the screen, you appear on the other side. It is the same concept here.\nTherefore, we have to define point addition and point multiplication differently. I have defined those functions in the helper file, and you can take a look at how they work if you’re interested.\nHere, we simply have to change the default addition and multiplication functions with point addition and point multiplication.\nPoint.__add__ = ec_addition # point addition Point.__rmul__ = double_and_add # point multiplication Now we are ready to generate our identity (i.e. private key).\n# identity 1 secret_key = int.from_bytes(b'super secret identity one', 'big') # for reproducibility  assert 1  sk  bitcoin_gen.n The generation of a private key is done automatically by your Bitcoin wallet application, and it should be doneusing a source of entropy to ensure complete randomness. Basically, it is extremely important that your private key is random, since that is the only guarantee you have that your pricate key is secure. If the random generator of your wallet is falwed or if your private key is ever exposed to someone else, it is no longer secure. Anyone with access to your private key can transfer all the funds associated with the key. So never share your private key and make sure your wallet application has a flawless random generator.\nBut for our educational purpose, we can create a static private key so that you can reproduce each step. Furthermore, we are using Testnet, so there’s no real bitcoin changing hands.\nOnce we have generated the private key, we simply perform elliptical curve multiplication with the generator point G to find the public key.\npublic_key = secret_key * G public_key Point(curve=Curve(p=115792089237316195423570985008687907853269984665640564039457584007908834671663, a=0, b=7), x=35490547311314112975969199385462927466356376524965552000974623035901126229990, y=75829577894590863462191837680945451999817850420713104019785938471674831323880)  You may be surprised to know that the public key is actually not a single value, but rather (x, y) coordinates. Intuitively this makes sense, since you are multiplying a randomly generated number by G, which is itself a coordinate on the secp256k1 curve.\nAt this point, the “public_key” variable is a Point object. But as we’ll see shortly, the Public Key takes on many forms and serves many purposes in a bitcoin transaction, so it’s kind of a big deal and deserves its own object.\nfrom helper import PublicKey Now, let’s see the various forms of the public key.\n  Public Key (Uncompressed) - In it’s original form, the public key it is a set of coordinates, (x, y) on the secp256k1 curve. Each of the coordinate is 256-bit in size, totalling 512 bits.\n  Public Key (Compresse) - it turns out that you can calculate y given x, so there is no point in storing the y value for a transaction. Since most transactions include the public key as part of its verification process, halving the size of the public key is a significant space reduction, from 512 to 256 bits\n  Public Key Hash - hashing the public key (compressed or uncompressed) using a combination of two hashing functions, SHA256 and RIPEMD160, will create the public key hash. In a P2PKH transaction, this is what you give out to the sender. It introduces another layer of security by introducing another trapdoor function and also further reduce the size of the transaction to 160 bits.\n  Bitcoin Address (Base58Check) - the final form of the public key is the Bitcoin Address. It is actually just another way to encode the public key hash to make it more human readable by using the Base58Check encoding. In this format, both uppercase and lowercase letters are used alongside numbers, but certain values are removed (i.e. zero and uppercase i) to reduce transcription errors. You won’t see the base58check encoded address format on the Bitcoin Protocol. Its purpose is purely for human readability.\n  public_key_compressed = PublicKey.from_point(pk).encode(compressed=True, hash160=False).hex() public_key_hash = PublicKey.from_point(public_key).encode(compressed=True, hash160=True).hex() bitcoin_address = PublicKey.from_point(public_key).address(net='test', compressed=True) print(\"Bitcoin Identity #1\") print(\"* Secret (Private) Key: \", secret_key) print(\"* Public key (uncompressed): \", (public_key.x, public_key.y)) print(\"* Public key (compressed): \", public_key_compressed) print(\"* Public key hash: \", public_key_hash) print(\"* Bitcoin address (base58check): \", bitcoin_address) Bitcoin Identity #1 * Secret (Private) Key: 724746296646138075612064989570816355802000824461885300502117 * Public key (uncompressed): (35490547311314112975969199385462927466356376524965552000974623035901126229990, 75829577894590863462191837680945451999817850420713104019785938471674831323880) * Public key (compressed): 024e76f01bc8ad2b0ca775ee0e392f52f5dd29e779388c6503044592c56f69bfe6 * Public key hash: 363bb1ef1d8791bdbd7e7492ef91decc1eb7295d * Bitcoin address (base58check): mkTiJ6dtXpYJqAremsCZtEww2XFWw3f2WT  Now let’s take a look at the outputs from our code above. Notice how much longer the uncompressed public key is? Also notice how much shorter the bitcoin address is when encoded in base58check?\nNow that we have our identity and account in the form of private key and public key, the final step is to receive some bitcoins!\nOrdinarily, this would involve you purchasing some bitcoin for cash, but in the magical world of Testnet, we can just ask for some!\nHead over to a Testnet Faucet, such as this one and simply enter the bitcoin address we just created, mkTiJ6dtXpYJqAremsCZtEww2XFWw3f2WT and an amount, 0.0001 bitcoin.\nAfter requesting the bitcoins, scroll down on the faucet page and you’ll see that the transaction has gone through and a transaction id has been generated: 6707af5c6d5257067c969fcf7f875e6ad9ad3143e3025f8c391683b23cff9c24. This is the transaction id (txid) that will uniquely identify this transaction on the blockchain.\nAlso notice that the transaction is pending.\nBitcoin is a peer-to-peer (p2p) network, and transactions are validated through concensus on this p2p network. When a transaction is first created, it is unconfirmed by any node on the network so it is pending. However, wait a few minutes and you’ll see some confirmations.\nYou can also head over to a block explorer website to see the transaction recorded on the blockchain (the Testnet blockchain that is). I used blockchain.com and searched for the public key hash generated earlier to find the transaction.\nFrom this transaction, you can see what happens when you asked for 0.0001 bitcoin from the Testnet Faucet. It creates a transaction which sends the fund to the bitcoin address you specified.\nIn Part 2, we will show you how to generate your own transaction, transferring some of the fund to a second address while sending the rest back. This will simulate a purchase and getting change back.\n",
  "wordCount" : "1967",
  "inLanguage": "en",
  "datePublished": "2022-02-12T17:51:29-08:00",
  "dateModified": "2022-02-12T17:51:29-08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://ergodefi.github.io/posts/1-bitcoin-pt1/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Michael Y. Han",
    "logo": {
      "@type": "ImageObject",
      "url": "https://ergodefi.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://ergodefi.github.io/" accesskey="h" title="Michael Y. Han (Alt + H)">Michael Y. Han</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Bitcoin transaction: a deep dive | Part 1
    </h1>
    <div class="post-meta"><span title='2022-02-12 17:51:29 -0800 PST'>February 12, 2022</span>

</div>
  </header> 
  <div class="post-content"><h3 id="overview">Overview<a hidden class="anchor" aria-hidden="true" href="#overview">#</a></h3>
<p>When you buy or sell bitcoin, the underlying transaction (i.e. deposit or withdraw) will be recorded and stored permanently on the Bitcoin Network, creating a massive decentralized ledger. This was one of the cornerstone concepts of Bitcoin.</p>
<p>The bitcoin transaction, and the cryptography behind it, is one of the most important and elegant part of Bitcoin. It also forms the foundation for other blockchain platforms, including Ethereum and Solana. So the way I see it, becoming intimately familiar with the inner workings of the bitcoin tranaction is a pre-requisite to getting into the defi space as an engineer or developer.</p>
<p>In this multi-part series, I am going to do a deep dive into this topic. You will see that with a little bit of know-how and some basic computer programming knowledge, you can see exactly what goes on in a bitcoin transaction.</p>
<p>We are going to go through, step-by-step, the creation of a bitcoin transaction, from creating your own wallet and receiving bitcoins to sending them in a transfer and unlocking the value with a digital signature. Furthermore, I am going to show you programmatically in Python, so that you see the technical implementation of this as well.</p>
<p>Most guides do not dive deep enough into the technical detals, so you end up only with superficial knowledge of the Bitcoin Protocol. To get that hands-on experience, we will use the Bitcoin Testnet to produce actual transactions (that you can verify on Block Explorer) and make everything replicable so that you can do the same.</p>
<p>I hope you are excited, because this is going to be a fun ride!</p>
<h3 id="part-1---keys-and-addresses-the-bank-accounts">Part 1 - Keys and Addresses (the &ldquo;Bank Accounts&rdquo;)<a hidden class="anchor" aria-hidden="true" href="#part-1---keys-and-addresses-the-bank-accounts">#</a></h3>
<p>To create a bitcoin transaction, we first need accounts to hold the bitcoins. In Bitcoin, this is commonly known as a wallet, but it is really just a collection of private keys. With the private key, you generate a public key that serves as your account number. Anyone who wishes to transfer you funds can do so by sending money to this account.</p>
<p>A private key is simply a string of randomly generated numbers that you hold, in private, which identifies you as the owner through the process of creating and signing digital signatures. We will cover digital signatures in Chapter 3.</p>
<p>The private key also generates the public key, but the reverse does not happen. This is known as a trap door function. As long as you, and only you, have possession of the private key, you can access the funds associated with the public key. In Bitcoin, the trap door function used is a form of Elliptic Curve Digital Signature Algorithm (ECDSA). We are not going to cover how ECDSA works as it is math heavy, but we are going to demonstrate how it works.</p>
<p>When Bitcoin was first introduced, this was, in a nutshell, how it worked. A transaction sent to a public key is known as a Pay to Public Key (P2PK) transaction. The first bitcoin transaction was a P2PK transaction.</p>
<p>Somewhere down the line, an improvement was made so that instead of giving out the public key, which is a massively long number, you give out a hash of the public key, a smaller number. A hashing function is a trap door function that takes the public key and creates the public key hash. This become known as a Pay to Public Key Hash (P2PKH) transaction. To date, P2PKH is the most common transaction on the Bitcoin Protocol. In the next chapter, we are going to generate a P2PKH transaction from scratch to show you how it all works.</p>
<p>[P2SH section]</p>
<p>In the coding portion below, I will generate a private key, use ECDSA to generate a public key and the hashing function to generate a public key hash. I will then transfer some bitcoins, on the Testnet using a faucet tool, to this address so that we have some funds to play with.</p>
<p>Let&rsquo;s start!</p>
<h3 id="a-note-about-coding">A note about coding<a hidden class="anchor" aria-hidden="true" href="#a-note-about-coding">#</a></h3>
<p>There is a lot of math used in implementing Bitcoin, but you don&rsquo;t need to fully understand them to understand Bitcoin. To make sure we can learn Bitcoin without being bogged down by the math, I created a helper file that has all of the needed algorithms and functions.</p>
<p>Make sure you download it and run it before you follow along with the code below.</p>
<h4 id="setup-the-helperpy-file">Setup the helper.py file<a hidden class="anchor" aria-hidden="true" href="#setup-the-helperpy-file">#</a></h4>
<p>First, let&rsquo;s import from helper.py. These are all data structures and functions that enable elliptical curve multiplication, the trapdoor function that generates the public key from the private key.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">from</span> helper <span style="color:#f92672">import</span> Curve, Point, Generator, ec_addition, double_and_add 
</code></pre></div><p>Once we have the structures, we can create the &ldquo;Bitcoin curve&rdquo; also known as the secp256k1, a specific type of ellitpical curve set over a finite field. We can define some constants at this point, including the generator point (G) and the point at infinity.</p>
<p>Don&rsquo;t worry if you are confused at this point. There are <a href="https://www.coindesk.com/markets/2014/10/19/the-math-behind-the-bitcoin-protocol/">lots</a> of great articles written to help you understand ellptical curve cryptography and how it works.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># secp256k1 ellptical curve constants - y^2 = x^3 + 7 (mod p)</span>
bitcoin_curve <span style="color:#f92672">=</span> Curve(
    p <span style="color:#f92672">=</span> <span style="color:#ae81ff">0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F</span>,
    a <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x0</span>, 
    b <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x7</span>, 
)

<span style="color:#75715e"># generator point </span>
G <span style="color:#f92672">=</span> Point(
    bitcoin_curve, 
    x <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798</span>, 
    y <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8</span>,
)

bitcoin_gen <span style="color:#f92672">=</span> Generator(
    G <span style="color:#f92672">=</span> G,
    n <span style="color:#f92672">=</span> <span style="color:#ae81ff">0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141</span>, 
)

<span style="color:#75715e"># point at infinity </span>
INF <span style="color:#f92672">=</span> Point(<span style="color:#66d9ef">None</span>, <span style="color:#66d9ef">None</span>, <span style="color:#66d9ef">None</span>) 
</code></pre></div><p>Because we are working with points on a finite field, the concept of addition and multiplication are also different. When addition or multiplication takes the value outside of the finite field, the value &ldquo;wraps around&rdquo; so that it would fall into this range.</p>
<p>If you have ever played classic games incluidng Asteriod or Donkey Kong, when you go out of bounds on one side of the screen, you appear on the other side. It is the same concept here.</p>
<p>Therefore, we have to define point addition and point multiplication differently. I have defined those functions in the helper file, and you can take a look at how they work if you&rsquo;re interested.</p>
<p>Here, we simply have to change the default addition and multiplication functions with point addition and point multiplication.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">Point<span style="color:#f92672">.</span>__add__ <span style="color:#f92672">=</span> ec_addition  <span style="color:#75715e"># point addition</span>
Point<span style="color:#f92672">.</span>__rmul__ <span style="color:#f92672">=</span> double_and_add <span style="color:#75715e"># point multiplication</span>
</code></pre></div><p>Now we are ready to generate our identity (i.e. private key).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># identity 1</span>
secret_key <span style="color:#f92672">=</span> int<span style="color:#f92672">.</span>from_bytes(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;super secret identity one&#39;</span>, <span style="color:#e6db74">&#39;big&#39;</span>) <span style="color:#75715e"># for reproducibility </span>
<span style="color:#66d9ef">assert</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;=</span> sk <span style="color:#f92672">&lt;</span> bitcoin_gen<span style="color:#f92672">.</span>n 

</code></pre></div><p>The generation of a private key is done automatically by your Bitcoin wallet application, and it should be doneusing a source of entropy to ensure complete randomness. Basically, it is extremely important that your private key is random, since that is the only guarantee you have that your pricate key is secure. If the random generator of your wallet is falwed or if your private key is ever exposed to someone else, it is no longer secure. Anyone with access to your private key can transfer all the funds associated with the key. So never share your private key and make sure your wallet application has a flawless random generator.</p>
<p>But for our educational purpose, we can create a static private key so that you can reproduce each step. Furthermore, we are using Testnet, so there&rsquo;s no real bitcoin changing hands.</p>
<p>Once we have generated the private key, we simply perform elliptical curve multiplication with the generator point G  to find the public key.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">public_key <span style="color:#f92672">=</span> secret_key <span style="color:#f92672">*</span> G
public_key
</code></pre></div><pre><code>Point(curve=Curve(p=115792089237316195423570985008687907853269984665640564039457584007908834671663, a=0, b=7), x=35490547311314112975969199385462927466356376524965552000974623035901126229990, y=75829577894590863462191837680945451999817850420713104019785938471674831323880)
</code></pre>
<p>You may be surprised to know that the public key is actually not a single value, but rather (x, y) coordinates. Intuitively this makes sense, since you are multiplying a randomly generated number by G, which is itself a coordinate on the secp256k1 curve.</p>
<p>At this point, the &ldquo;public_key&rdquo; variable is a Point object. But as we&rsquo;ll see shortly, the Public Key takes on many forms and serves many purposes in a bitcoin transaction, so it&rsquo;s kind of a big deal and deserves its own object.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">from</span> helper <span style="color:#f92672">import</span> PublicKey
</code></pre></div><p>Now, let&rsquo;s see the various forms of the public key.</p>
<ol>
<li>
<p><strong>Public Key (Uncompressed)</strong> - In it&rsquo;s original form, the public key it is a set of coordinates, (x, y) on the secp256k1 curve. Each of the coordinate is 256-bit in size, totalling 512 bits.</p>
</li>
<li>
<p><strong>Public Key (Compresse)</strong> - it turns out that you can calculate y given x, so there is no point in storing the y value for a transaction. Since most transactions include the public key as part of its verification process, halving the size of the public key is a significant space reduction, from 512 to 256 bits</p>
</li>
<li>
<p><strong>Public Key Hash</strong> - hashing the public key (compressed or uncompressed) using a combination of two hashing functions, SHA256 and RIPEMD160, will create the public key hash. In a P2PKH transaction, this is what you give out to the sender. It introduces another layer of security by introducing another trapdoor function and also further reduce the size of the transaction to 160 bits.</p>
</li>
<li>
<p><strong>Bitcoin Address (Base58Check)</strong> - the final form of the public key is the Bitcoin Address. It is actually just another way to encode the public key hash to make it more human readable by using the Base58Check encoding. In this format, both uppercase and lowercase letters are used alongside numbers, but certain values are removed (i.e. zero and uppercase i) to reduce transcription errors. You won&rsquo;t see the base58check encoded address format on the Bitcoin Protocol. Its purpose is purely for human readability.</p>
</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">public_key_compressed <span style="color:#f92672">=</span> PublicKey<span style="color:#f92672">.</span>from_point(pk)<span style="color:#f92672">.</span>encode(compressed<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>, hash160<span style="color:#f92672">=</span><span style="color:#66d9ef">False</span>)<span style="color:#f92672">.</span>hex()
public_key_hash <span style="color:#f92672">=</span> PublicKey<span style="color:#f92672">.</span>from_point(public_key)<span style="color:#f92672">.</span>encode(compressed<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>, hash160<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>)<span style="color:#f92672">.</span>hex()
bitcoin_address <span style="color:#f92672">=</span> PublicKey<span style="color:#f92672">.</span>from_point(public_key)<span style="color:#f92672">.</span>address(net<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;test&#39;</span>, compressed<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>)

print(<span style="color:#e6db74">&#34;Bitcoin Identity #1&#34;</span>)
print(<span style="color:#e6db74">&#34;* Secret (Private) Key: &#34;</span>, secret_key)
print(<span style="color:#e6db74">&#34;* Public key (uncompressed): &#34;</span>, (public_key<span style="color:#f92672">.</span>x, public_key<span style="color:#f92672">.</span>y))
print(<span style="color:#e6db74">&#34;* Public key (compressed): &#34;</span>, public_key_compressed) 
print(<span style="color:#e6db74">&#34;* Public key hash: &#34;</span>, public_key_hash) 
print(<span style="color:#e6db74">&#34;* Bitcoin address (base58check): &#34;</span>, bitcoin_address)
</code></pre></div><pre><code>Bitcoin Identity #1
* Secret (Private) Key:  724746296646138075612064989570816355802000824461885300502117
* Public key (uncompressed):  (35490547311314112975969199385462927466356376524965552000974623035901126229990, 75829577894590863462191837680945451999817850420713104019785938471674831323880)
* Public key (compressed):  024e76f01bc8ad2b0ca775ee0e392f52f5dd29e779388c6503044592c56f69bfe6
* Public key hash:  363bb1ef1d8791bdbd7e7492ef91decc1eb7295d
* Bitcoin address (base58check):  mkTiJ6dtXpYJqAremsCZtEww2XFWw3f2WT
</code></pre>
<p>Now let&rsquo;s take a look at the outputs from our code above. Notice how much longer the uncompressed public key is? Also notice how much shorter the bitcoin address is when encoded in base58check?</p>
<p>Now that we have our identity and account in the form of private key and public key, the final step is to receive some bitcoins!</p>
<p>Ordinarily, this would involve you purchasing some bitcoin for cash, but in the magical world of Testnet, we can just ask for some!</p>
<p>Head over to a Testnet Faucet, such as this <a href="https://bitcoinfaucet.uo1.net/">one</a> and simply enter the bitcoin address we just created, <em>mkTiJ6dtXpYJqAremsCZtEww2XFWw3f2WT</em> and an amount, <em>0.0001</em> bitcoin.</p>
<p><img loading="lazy" src="/images/testnet_faucet_transfer.png" alt="Testnet Faucet Transfer"  />
</p>
<p>After requesting the bitcoins, scroll down on the faucet page and you&rsquo;ll see that the transaction has gone through and a transaction id has been generated: <em>6707af5c6d5257067c969fcf7f875e6ad9ad3143e3025f8c391683b23cff9c24</em>. This is the transaction id (txid) that will uniquely identify this transaction on the blockchain.</p>
<p><img loading="lazy" src="/images/testnet_faucet_pending.png" alt="Testnet Faucet Pending"  />
</p>
<p>Also notice that the transaction is pending.</p>
<p>Bitcoin is a peer-to-peer (p2p) network, and transactions are validated through concensus on this p2p network. When a transaction is first created, it is unconfirmed by any node on the network so it is pending. However, wait a few minutes and you&rsquo;ll see some confirmations.</p>
<p><img loading="lazy" src="/images/testnet_faucet_confirmed.png" alt="Testnet Faucet Confirmed"  />
</p>
<p>You can also head over to a block explorer website to see the transaction recorded on the blockchain (the Testnet blockchain that is). I used blockchain.com and searched for the public key hash generated earlier to find the <a href="https://www.blockchain.com/btc-testnet/tx/6707af5c6d5257067c969fcf7f875e6ad9ad3143e3025f8c391683b23cff9c24">transaction</a>.</p>
<p><img loading="lazy" src="/images/blockexplorer_faucet_tx.png" alt="Block Explorer Transaction"  />
</p>
<p>From this transaction, you can see what happens when you asked for 0.0001 bitcoin from the Testnet Faucet. It creates a transaction which sends the fund to the bitcoin address you specified.</p>
<p>In <strong>Part 2</strong>, we will show you how to generate your own transaction, transferring some of the fund to a second address while sending the rest back. This will simulate a purchase and getting change back.</p>


  </div>

  <footer class="post-footer">
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2022 <a href="https://ergodefi.github.io/">Michael Y. Han</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
