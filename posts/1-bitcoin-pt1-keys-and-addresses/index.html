<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Bitcoin Transactions - Part 1: Keys and Addresses | Michael Y. Han</title>
<meta name="keywords" content="" />
<meta name="description" content="When you buy or sell bitcoin, the transaction will be recorded and stored permanently on the Bitcoin network. The bitcoin transaction, and the cryptography behind it, is one of the most important and elegant part of Bitcoin. It also forms the foundation for other cryptocurrencies and blockchain platforms, including Ethereum and Solana. So becoming intimately familiar with the inner workings of the bitcoin tranaction is a pre-requisite to getting into the defi space as an engineer or developer.">
<meta name="author" content="">
<link rel="canonical" href="https://yugomike.github.io/posts/1-bitcoin-pt1-keys-and-addresses/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css" integrity="sha256-yIlj/i15RiAA/Q&#43;xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.4dcb3c4f38462f66c6b6137227726f5543cb934cca9788f041c087e374491df2.js" integrity="sha256-Tcs8TzhGL2bGthNyJ3JvVUPLk0zKl4jwQcCH43RJHfI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://yugomike.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://yugomike.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://yugomike.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://yugomike.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://yugomike.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Bitcoin Transactions - Part 1: Keys and Addresses" />
<meta property="og:description" content="When you buy or sell bitcoin, the transaction will be recorded and stored permanently on the Bitcoin network. The bitcoin transaction, and the cryptography behind it, is one of the most important and elegant part of Bitcoin. It also forms the foundation for other cryptocurrencies and blockchain platforms, including Ethereum and Solana. So becoming intimately familiar with the inner workings of the bitcoin tranaction is a pre-requisite to getting into the defi space as an engineer or developer." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://yugomike.github.io/posts/1-bitcoin-pt1-keys-and-addresses/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-02-12T17:51:29-08:00" />
<meta property="article:modified_time" content="2022-02-12T17:51:29-08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Bitcoin Transactions - Part 1: Keys and Addresses"/>
<meta name="twitter:description" content="When you buy or sell bitcoin, the transaction will be recorded and stored permanently on the Bitcoin network. The bitcoin transaction, and the cryptography behind it, is one of the most important and elegant part of Bitcoin. It also forms the foundation for other cryptocurrencies and blockchain platforms, including Ethereum and Solana. So becoming intimately familiar with the inner workings of the bitcoin tranaction is a pre-requisite to getting into the defi space as an engineer or developer."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://yugomike.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Bitcoin Transactions - Part 1: Keys and Addresses",
      "item": "https://yugomike.github.io/posts/1-bitcoin-pt1-keys-and-addresses/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Bitcoin Transactions - Part 1: Keys and Addresses",
  "name": "Bitcoin Transactions - Part 1: Keys and Addresses",
  "description": "When you buy or sell bitcoin, the transaction will be recorded and stored permanently on the Bitcoin network. The bitcoin transaction, and the cryptography behind it, is one of the most important and elegant part of Bitcoin. It also forms the foundation for other cryptocurrencies and blockchain platforms, including Ethereum and Solana. So becoming intimately familiar with the inner workings of the bitcoin tranaction is a pre-requisite to getting into the defi space as an engineer or developer.",
  "keywords": [
    
  ],
  "articleBody": "When you buy or sell bitcoin, the transaction will be recorded and stored permanently on the Bitcoin network. The bitcoin transaction, and the cryptography behind it, is one of the most important and elegant part of Bitcoin. It also forms the foundation for other cryptocurrencies and blockchain platforms, including Ethereum and Solana. So becoming intimately familiar with the inner workings of the bitcoin tranaction is a pre-requisite to getting into the defi space as an engineer or developer.\nIn this multi-part series, I am going to do a deep dive into this topic. You will see that with a little bit of know-how and some computer programming knowledge, you can recreate many parts of the Bitcoin protocol and see exactly how the bitcoin transaction works.\nMost guides do not dive deeply into the code, so you end up only with superficial knowledge of the Bitcoin protocol. To get that next level hands-on experience, we will use the Bitcoin Testnet to produce actual transactions that you can verify on Block Explorer and do it all using Python.\nI hope you are excited, because this is going to be a fun ride!\nPart 1 - Keys and Addresses (the “Bank Accounts”) To create a bitcoin transaction, we first need accounts to hold the funds. In Bitcoin, this is commonly known as a wallet, but it is really just a collection of private and public key pairs. Using your randomly generated private key, you generate a public key that serves as your account number. Anyone who wishes to transfer you funds can do so by sending money to this account. You then verify that you have possession of the private key through a digital signature.\nIn Part 1, we cover how to generate the private and public keys, and in Part 2 we will discuss the digital signature in more detail.\nA private key is simply a string of randomly generated numbers. Anyone who has possession of the private key has access to funds associated with it. Therefore, it is also known as a “secret key” because you need to store this number privately. The private key is used to generate the public key, in a one-way (or trapdoor) function. This means you can generate the public key with the private key, but the reverse cannot be done. In Bitcoin, the trap door function used is the Elliptic Curve Digital Signature Algorithm (ECDSA).\nIn contrast with the private key, the public key is the address that you can freely give out to people who want to transact with you. A transaction sent to a public key is known as a Pay-to-Public-Key (P2PK) transaction. The first bitcoin transaction was a P2PK transaction. This type of transaction is not common anymore as it has been replaced by another form of transaction, the Pay-to-Public-Key-Hash (P2PKH).\nInstead of giving out the public key, which is a massively long number, you give out a hash of the public key, a much smaller number. A hashing function is another type of trap door function, which takes the public key and creates the public key hash. The hashing process adds another layer of security. To date, P2PKH is the most common transaction on the Bitcoin Protocol. We are going to generate a P2PKH transaction from scratch to show you how it all works.\nIn 2012 another type of transaction was introduced, known as Pay-to-Script-Hash (P2SH). Instead of sending funds directly to a recipient’s public key or public key hash, a P2SH transaction sends funds to a script that has custom logic and conditions that allow for more complex transactions. An example of P2SH is a multisig transaction, which requires multiple people’s digital signatures to unlock the funds. we will cover both P2PKH and P2SH in this series.\nIt’s coding time! In the coding portion below, I will generate a private key, use ECDSA to generate a public key and the hashing function to generate a public key hash. I will then transfer some bitcoins to this address so that we have some funds to play with and craft our own P2PKH transaction.\nLet’s start!\nSetup the helper.py file There is a lot of math in Bitcoin, but you don’t need to fully understand them to learn how Bitcoin works. To make sure we can learn Bitcoin without being bogged down by the math, I created a helper file that has all of the needed algorithms and functions.\nTo get started and follow along, you can clone my Github repo by typing the command below in terminal and then open it up in your editor of choice. I use Visual Studio Code.\ngit clone -b 0-getting-started https://github.com/ergodefi/btc-deepdive.git Next, we are going to import the helper file and its useful library of data structures and functions.\nfrom helper import Curve, Point, Generator, ec_addition, double_and_add We can now finally start slinging some codes!\nFirst, we need to build parts of the ECDSA algorithm, which is the trapdoor function used to generate the public key from the private key.\nWe can now start by creating the “Bitcoin curve” also known as the secp256k1, a specific type of ellitpical curve set over a finite field. We can define some constants at this point, including the generator point (G) and the point at infinity.\nDon’t worry if you are confused at this point. There are lots of great articles written to help you understand ellptical curve cryptography and how it works.\n# secp256k1 ellptical curve constants - y^2 = x^3 + 7 (mod p) bitcoin_curve = Curve(  p = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F,  a = 0x0,  b = 0x7, )  # generator point  G = Point(  bitcoin_curve,  x = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798,  y = 0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8, )  bitcoin_gen = Generator(  G = G,  n = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141, )  # point at infinity  INF = Point(None, None, None) Because we are working with points on a finite field, the concept of addition and multiplication are also different. When addition or multiplication takes the value outside of the finite field, the value “wraps around” so that it would fall into this range.\nIf you have ever played classic games incluidng Asteriod or Donkey Kong, when you go out of bounds on one side of the screen, you appear on the other side. It is the same concept here.\nTherefore, we have to define point addition and point multiplication differently. I have defined those functions in the helper file, and you can take a look at how they work if you’re interested.\nHere, we simply have to change the default addition and multiplication functions with point addition and point multiplication.\nPoint.__add__ = ec_addition # point addition Point.__rmul__ = double_and_add # point multiplication Now we are ready to generate our identity (i.e. private key).\n# identity 1 secret_key = int.from_bytes(b'super secret identity one', 'big') # for reproducibility  assert 1  secret_key  bitcoin_gen.n The generation of a private key is done automatically by your Bitcoin wallet application, and it should be doneusing a source of entropy to ensure complete randomness. Basically, it is extremely important that your private key is random, since that is the only guarantee you have that your pricate key is secure. If the random generator of your wallet is falwed or if your private key is ever exposed to someone else, it is no longer secure. Anyone with access to your private key can transfer all the funds associated with the key. So never share your private key and make sure your wallet application has a flawless random generator.\nBut for our educational purpose, we can create a static private key so that you can reproduce each step. Furthermore, we are using Testnet, so there’s no real bitcoin changing hands.\nOnce we have generated the private key, we simply perform elliptical curve multiplication with the generator point G to find the public key.\npublic_key = secret_key * G print(public_key) Point(curve=Curve(p=115792089237316195423570985008687907853269984665640564039457584007908834671663, a=0, b=7), x=35490547311314112975969199385462927466356376524965552000974623035901126229990, y=75829577894590863462191837680945451999817850420713104019785938471674831323880)\nYou may be surprised to know that the public key is actually not a single value, but rather a set of (x, y) coordinates. Intuitively this makes sense, since you are multiplying a randomly generated number by G, which is itself a coordinate on the secp256k1 curve.\nAs we’ll see shortly, the public key can take on many forms and has many variations. It’s kind of a big deal and deserves its own class, which I have created in helper.py. We just need to import it.\nfrom helper import PublicKey Now, let’s see the various forms of the public key.\n  Public Key (Uncompressed) - In it’s original form, the public key it is a set of coordinates, (x, y) on the secp256k1 curve. Each of the coordinate is 256-bit in size, totalling 512 bits.\n  Public Key (Compresse) - it turns out that you can calculate y given x, so there is no point in storing the y value for a transaction. Since most transactions include the public key as part of its verification process, halving the size of the public key is a significant space reduction, from 512 to 256 bits\n  Public Key Hash - hashing the public key using a combination of two hashing functions, SHA256 and RIPEMD160, will create the public key hash. In a P2PKH transaction, it is used to provide an extra layer of security.\n  Bitcoin Address (Base58Check) - the final form of the public key is the Bitcoin Address. It is actually just another way to encode the public key hash to make it more human readable by using the Base58Check encoding. In this format, both uppercase and lowercase letters are used alongside numbers, but certain values are removed (i.e. zero and uppercase i) to reduce transcription errors. You won’t see the base58check encoded address format on the Bitcoin Protocol. Its purpose is purely for human readability.\n  public_key_compressed = PublicKey.from_point(public_key).encode(compressed=True, hash160=False).hex() public_key_hash = PublicKey.from_point(public_key).encode(compressed=True, hash160=True).hex() bitcoin_address = PublicKey.from_point(public_key).address(net='test', compressed=True)  print(\"Bitcoin Identity #1\") print(\"* Secret (Private) Key: \", secret_key) print(\"* Public key (uncompressed): \", (public_key.x, public_key.y)) print(\"* Public key (compressed): \", public_key_compressed) print(\"* Public key hash: \", public_key_hash) print(\"* Bitcoin address (base58check): \", bitcoin_address) Bitcoin Identity #1 * Secret (Private) Key: 724746296646138075612064989570816355802000824461885300502117 * Public key (uncompressed): (35490547311314112975969199385462927466356376524965552000974623035901126229990, 75829577894590863462191837680945451999817850420713104019785938471674831323880) * Public key (compressed): 024e76f01bc8ad2b0ca775ee0e392f52f5dd29e779388c6503044592c56f69bfe6 * Public key hash: 363bb1ef1d8791bdbd7e7492ef91decc1eb7295d * Bitcoin address (base58check): mkTiJ6dtXpYJqAremsCZtEww2XFWw3f2WT Now let’s take a look at the outputs from our code above. Notice how much longer the uncompressed public key is? Also notice how much shorter the bitcoin address is when encoded in base58check?\nNow that we have our identity and account in the form of private key and public key, the final step is to receive some bitcoins!\nOrdinarily, this would involve you purchasing some bitcoin for cash, but in the magical world of Testnet, we can just ask for some!\nHead over to a Testnet Faucet, such as this one and simply enter the bitcoin address we just created, mkTiJ6dtXpYJqAremsCZtEww2XFWw3f2WT and an amount, 0.0001 bitcoin.\nAfter requesting the bitcoins, scroll down on the faucet page and you’ll see that the transaction has gone through and a transaction id has been generated: 6707af5c6d5257067c969fcf7f875e6ad9ad3143e3025f8c391683b23cff9c24. This is the transaction id (txid) that will uniquely identify this transaction on the blockchain.\nAlso notice that the transaction is pending.\nBitcoin is a peer-to-peer (p2p) network, and transactions are validated through concensus on this p2p network. When a transaction is first created, it is unconfirmed by any node on the network so it is pending. However, wait a few minutes and you’ll see some confirmations.\nYou can also head over to a block explorer website to see the transaction recorded on the blockchain (the Testnet blockchain that is). I used blockchain.com and searched for the public key hash generated earlier to find the transaction.\nFrom this transaction, you can see what happens when you asked for 0.0001 bitcoin from the Testnet Faucet. It creates a transaction which sends the fund to the bitcoin address you specified. In the next part, I will show you how to generate your own bitcoin transaction to transfer some of the fund to a second address while sending the rest back to this one. This will simulate a purchase and getting change back. Stay tuned!\n",
  "wordCount" : "2014",
  "inLanguage": "en",
  "datePublished": "2022-02-12T17:51:29-08:00",
  "dateModified": "2022-02-12T17:51:29-08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://yugomike.github.io/posts/1-bitcoin-pt1-keys-and-addresses/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Michael Y. Han",
    "logo": {
      "@type": "ImageObject",
      "url": "https://yugomike.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://yugomike.github.io/" accesskey="h" title="Michael Y. Han (Alt + H)">Michael Y. Han</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Bitcoin Transactions - Part 1: Keys and Addresses
    </h1>
    <div class="post-meta"><span title='2022-02-12 17:51:29 -0800 PST'>February 12, 2022</span>

</div>
  </header> 
  <div class="post-content"><p>When you buy or sell bitcoin, the transaction  will be recorded and stored permanently on the Bitcoin network. The bitcoin transaction, and the cryptography behind it, is one of the most important and elegant part of Bitcoin. It also forms the foundation for other cryptocurrencies and blockchain platforms, including Ethereum and Solana. So becoming intimately familiar with the inner workings of the bitcoin tranaction is a pre-requisite to getting into the defi space as an engineer or developer.</p>
<p>In this multi-part series, I am going to do a deep dive into this topic. You will see that with a little bit of know-how and some computer programming knowledge, you can recreate many parts of the Bitcoin protocol and see exactly how the bitcoin transaction works.</p>
<p>Most guides do not dive deeply into the code, so you end up only with superficial knowledge of the Bitcoin protocol. To get that next level hands-on experience, we will use the Bitcoin Testnet to produce actual transactions that you can verify on Block Explorer and do it all using Python.</p>
<p>I hope you are excited, because this is going to be a fun ride!</p>
<h3 id="part-1---keys-and-addresses-the-bank-accounts">Part 1 - Keys and Addresses (the &ldquo;Bank Accounts&rdquo;)<a hidden class="anchor" aria-hidden="true" href="#part-1---keys-and-addresses-the-bank-accounts">#</a></h3>
<p>To create a bitcoin transaction, we first need accounts to hold the funds. In Bitcoin, this is commonly known as a wallet, but it is really just a collection of private and public key pairs. Using your randomly generated private key, you generate a public key that serves as your account number. Anyone who wishes to transfer you funds can do so by sending money to this account. You then verify that you have possession of the private key through a digital signature.</p>
<p>In Part 1, we cover how to generate the private and public keys, and in Part 2 we will discuss the digital signature in more detail.</p>
<p>A private key is simply a string of randomly generated numbers. Anyone who has possession of the private key has access to funds associated with it. Therefore, it is also known as a &ldquo;secret key&rdquo; because you need to store this number privately. The private key is used to generate the public key, in a one-way (or trapdoor) function. This means you can generate the public key with the private key, but the reverse cannot be done. In Bitcoin, the trap door function used is the Elliptic Curve Digital Signature Algorithm (ECDSA).</p>
<p>In contrast with the private key, the public key is the address that you can freely give out to people who want to transact with you. A transaction sent to a public key is known as a Pay-to-Public-Key (P2PK) transaction. The first bitcoin transaction was a P2PK transaction. This type of transaction is not common anymore as it has been replaced by another form of transaction, the Pay-to-Public-Key-Hash (P2PKH).</p>
<p>Instead of giving out the public key, which is a massively long number, you give out a hash of the public key, a much smaller number. A hashing function is another type of trap door function, which takes the public key and creates the public key hash. The hashing process adds another layer of security. To date, P2PKH is the most common transaction on the Bitcoin Protocol. We are going to generate a P2PKH transaction from scratch to show you how it all works.</p>
<p>In 2012 another type of transaction was introduced, known as Pay-to-Script-Hash (P2SH). Instead of sending funds directly to a recipient&rsquo;s public key or public key hash, a P2SH transaction sends funds to a script that has custom logic and conditions that allow for more complex transactions. An example of P2SH is a multisig transaction, which requires multiple people&rsquo;s digital signatures to unlock the funds. we will cover both P2PKH and P2SH in this series.</p>
<h3 id="its-coding-time">It&rsquo;s coding time!<a hidden class="anchor" aria-hidden="true" href="#its-coding-time">#</a></h3>
<p>In the coding portion below, I will generate a private key, use ECDSA to generate a public key and the hashing function to generate a public key hash. I will then transfer some bitcoins to this address so that we have some funds to play with and craft our own P2PKH transaction.</p>
<p>Let&rsquo;s start!</p>
<h3 id="setup-the-helperpy-file">Setup the helper.py file<a hidden class="anchor" aria-hidden="true" href="#setup-the-helperpy-file">#</a></h3>
<p>There is a lot of math in Bitcoin, but you don&rsquo;t need to fully understand them to learn how Bitcoin works. To make sure we can learn Bitcoin without being bogged down by the math, I created a helper file that has all of the needed algorithms and functions.</p>
<p>To get started and follow along, you can clone my Github repo by typing the command below in terminal and then open it up in your editor of choice. I use Visual Studio Code.</p>
<pre tabindex="0"><code>git clone -b 0-getting-started https://github.com/ergodefi/btc-deepdive.git
</code></pre><p>Next, we are going to import the helper file and its useful library of data structures and functions.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">from</span> helper <span style="color:#f92672">import</span> Curve, Point, Generator, ec_addition, double_and_add 
</span></span></code></pre></div><p>We can now finally start slinging some codes!</p>
<p>First, we need to build parts of the ECDSA algorithm, which is the trapdoor function used to generate the public key from the private key.</p>
<p>We can now start by creating the &ldquo;Bitcoin curve&rdquo; also known as the secp256k1, a specific type of ellitpical curve set over a finite field. We can define some constants at this point, including the generator point (G) and the point at infinity.</p>
<p>Don&rsquo;t worry if you are confused at this point. There are <a href="https://www.coindesk.com/markets/2014/10/19/the-math-behind-the-bitcoin-protocol/">lots</a> of great articles written to help you understand ellptical curve cryptography and how it works.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># secp256k1 ellptical curve constants - y^2 = x^3 + 7 (mod p)</span>
</span></span><span style="display:flex;"><span>bitcoin_curve <span style="color:#f92672">=</span> Curve(
</span></span><span style="display:flex;"><span>    p <span style="color:#f92672">=</span> <span style="color:#ae81ff">0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F</span>,
</span></span><span style="display:flex;"><span>    a <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x0</span>, 
</span></span><span style="display:flex;"><span>    b <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x7</span>, 
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># generator point </span>
</span></span><span style="display:flex;"><span>G <span style="color:#f92672">=</span> Point(
</span></span><span style="display:flex;"><span>    bitcoin_curve, 
</span></span><span style="display:flex;"><span>    x <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798</span>, 
</span></span><span style="display:flex;"><span>    y <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8</span>,
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>bitcoin_gen <span style="color:#f92672">=</span> Generator(
</span></span><span style="display:flex;"><span>    G <span style="color:#f92672">=</span> G,
</span></span><span style="display:flex;"><span>    n <span style="color:#f92672">=</span> <span style="color:#ae81ff">0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141</span>, 
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># point at infinity </span>
</span></span><span style="display:flex;"><span>INF <span style="color:#f92672">=</span> Point(<span style="color:#66d9ef">None</span>, <span style="color:#66d9ef">None</span>, <span style="color:#66d9ef">None</span>) 
</span></span></code></pre></div><p>Because we are working with points on a finite field, the concept of addition and multiplication are also different. When addition or multiplication takes the value outside of the finite field, the value &ldquo;wraps around&rdquo; so that it would fall into this range.</p>
<p>If you have ever played classic games incluidng Asteriod or Donkey Kong, when you go out of bounds on one side of the screen, you appear on the other side. It is the same concept here.</p>
<p>Therefore, we have to define point addition and point multiplication differently. I have defined those functions in the helper file, and you can take a look at how they work if you&rsquo;re interested.</p>
<p>Here, we simply have to change the default addition and multiplication functions with point addition and point multiplication.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>Point<span style="color:#f92672">.</span>__add__ <span style="color:#f92672">=</span> ec_addition  <span style="color:#75715e"># point addition</span>
</span></span><span style="display:flex;"><span>Point<span style="color:#f92672">.</span>__rmul__ <span style="color:#f92672">=</span> double_and_add <span style="color:#75715e"># point multiplication</span>
</span></span></code></pre></div><p>Now we are ready to generate our identity (i.e. private key).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># identity 1</span>
</span></span><span style="display:flex;"><span>secret_key <span style="color:#f92672">=</span> int<span style="color:#f92672">.</span>from_bytes(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;super secret identity one&#39;</span>, <span style="color:#e6db74">&#39;big&#39;</span>) <span style="color:#75715e"># for reproducibility </span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">assert</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;=</span> secret_key <span style="color:#f92672">&lt;</span> bitcoin_gen<span style="color:#f92672">.</span>n 
</span></span></code></pre></div><p>The generation of a private key is done automatically by your Bitcoin wallet application, and it should be doneusing a source of entropy to ensure complete randomness. Basically, it is extremely important that your private key is random, since that is the only guarantee you have that your pricate key is secure. If the random generator of your wallet is falwed or if your private key is ever exposed to someone else, it is no longer secure. Anyone with access to your private key can transfer all the funds associated with the key. So never share your private key and make sure your wallet application has a flawless random generator.</p>
<p>But for our educational purpose, we can create a static private key so that you can reproduce each step. Furthermore, we are using Testnet, so there&rsquo;s no real bitcoin changing hands.</p>
<p>Once we have generated the private key, we simply perform elliptical curve multiplication with the generator point G  to find the public key.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>public_key <span style="color:#f92672">=</span> secret_key <span style="color:#f92672">*</span> G
</span></span><span style="display:flex;"><span>print(public_key)
</span></span></code></pre></div><p><code>Point(curve=Curve(p=115792089237316195423570985008687907853269984665640564039457584007908834671663, a=0, b=7), x=35490547311314112975969199385462927466356376524965552000974623035901126229990, y=75829577894590863462191837680945451999817850420713104019785938471674831323880)</code></p>
<p>You may be surprised to know that the public key is actually not a single value, but rather a set of (x, y) coordinates. Intuitively this makes sense, since you are multiplying a randomly generated number by G, which is itself a coordinate on the secp256k1 curve.</p>
<p>As we&rsquo;ll see shortly, the public key can take on many forms and has many variations. It&rsquo;s kind of a big deal and deserves its own class, which I have created in <em>helper.py</em>. We just need to import it.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">from</span> helper <span style="color:#f92672">import</span> PublicKey
</span></span></code></pre></div><p>Now, let&rsquo;s see the various forms of the public key.</p>
<ol>
<li>
<p><strong>Public Key (Uncompressed)</strong> - In it&rsquo;s original form, the public key it is a set of coordinates, (x, y) on the secp256k1 curve. Each of the coordinate is 256-bit in size, totalling 512 bits.</p>
</li>
<li>
<p><strong>Public Key (Compresse)</strong> - it turns out that you can calculate y given x, so there is no point in storing the y value for a transaction. Since most transactions include the public key as part of its verification process, halving the size of the public key is a significant space reduction, from 512 to 256 bits</p>
</li>
<li>
<p><strong>Public Key Hash</strong> - hashing the public key using a combination of two hashing functions, SHA256 and RIPEMD160, will create the public key hash. In a P2PKH transaction, it is used to provide an extra layer of security.</p>
</li>
<li>
<p><strong>Bitcoin Address (Base58Check)</strong> - the final form of the public key is the Bitcoin Address. It is actually just another way to encode the public key hash to make it more human readable by using the Base58Check encoding. In this format, both uppercase and lowercase letters are used alongside numbers, but certain values are removed (i.e. zero and uppercase i) to reduce transcription errors. You won&rsquo;t see the base58check encoded address format on the Bitcoin Protocol. Its purpose is purely for human readability.</p>
</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>public_key_compressed <span style="color:#f92672">=</span> PublicKey<span style="color:#f92672">.</span>from_point(public_key)<span style="color:#f92672">.</span>encode(compressed<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>, hash160<span style="color:#f92672">=</span><span style="color:#66d9ef">False</span>)<span style="color:#f92672">.</span>hex()
</span></span><span style="display:flex;"><span>public_key_hash <span style="color:#f92672">=</span> PublicKey<span style="color:#f92672">.</span>from_point(public_key)<span style="color:#f92672">.</span>encode(compressed<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>, hash160<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>)<span style="color:#f92672">.</span>hex()
</span></span><span style="display:flex;"><span>bitcoin_address <span style="color:#f92672">=</span> PublicKey<span style="color:#f92672">.</span>from_point(public_key)<span style="color:#f92672">.</span>address(net<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;test&#39;</span>, compressed<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;Bitcoin Identity #1&#34;</span>)
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;* Secret (Private) Key: &#34;</span>, secret_key)
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;* Public key (uncompressed): &#34;</span>, (public_key<span style="color:#f92672">.</span>x, public_key<span style="color:#f92672">.</span>y))
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;* Public key (compressed): &#34;</span>, public_key_compressed) 
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;* Public key hash: &#34;</span>, public_key_hash) 
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;* Bitcoin address (base58check): &#34;</span>, bitcoin_address)
</span></span></code></pre></div><pre tabindex="0"><code class="language-output" data-lang="output">Bitcoin Identity #1
* Secret (Private) Key:  724746296646138075612064989570816355802000824461885300502117
* Public key (uncompressed):  (35490547311314112975969199385462927466356376524965552000974623035901126229990, 75829577894590863462191837680945451999817850420713104019785938471674831323880)
* Public key (compressed):  024e76f01bc8ad2b0ca775ee0e392f52f5dd29e779388c6503044592c56f69bfe6
* Public key hash:  363bb1ef1d8791bdbd7e7492ef91decc1eb7295d
* Bitcoin address (base58check):  mkTiJ6dtXpYJqAremsCZtEww2XFWw3f2WT
</code></pre><p>Now let&rsquo;s take a look at the outputs from our code above. Notice how much longer the uncompressed public key is? Also notice how much shorter the bitcoin address is when encoded in base58check?</p>
<p>Now that we have our identity and account in the form of private key and public key, the final step is to receive some bitcoins!</p>
<p>Ordinarily, this would involve you purchasing some bitcoin for cash, but in the magical world of Testnet, we can just ask for some!</p>
<p>Head over to a Testnet Faucet, such as this <a href="https://bitcoinfaucet.uo1.net/">one</a> and simply enter the bitcoin address we just created, <em>mkTiJ6dtXpYJqAremsCZtEww2XFWw3f2WT</em> and an amount, <em>0.0001</em> bitcoin.</p>
<p><img loading="lazy" src="/images/testnet_faucet_transfer.png" alt="Testnet Faucet Transfer"  />
</p>
<p>After requesting the bitcoins, scroll down on the faucet page and you&rsquo;ll see that the transaction has gone through and a transaction id has been generated: <em>6707af5c6d5257067c969fcf7f875e6ad9ad3143e3025f8c391683b23cff9c24</em>. This is the transaction id (txid) that will uniquely identify this transaction on the blockchain.</p>
<p><img loading="lazy" src="/images/testnet_faucet_pending.png" alt="Testnet Faucet Pending"  />
</p>
<p>Also notice that the transaction is pending.</p>
<p>Bitcoin is a peer-to-peer (p2p) network, and transactions are validated through concensus on this p2p network. When a transaction is first created, it is unconfirmed by any node on the network so it is pending. However, wait a few minutes and you&rsquo;ll see some confirmations.</p>
<p><img loading="lazy" src="/images/testnet_faucet_confirmed.png" alt="Testnet Faucet Confirmed"  />
</p>
<p>You can also head over to a block explorer website to see the transaction recorded on the blockchain (the Testnet blockchain that is). I used blockchain.com and searched for the public key hash generated earlier to find the <a href="https://www.blockchain.com/btc-testnet/tx/6707af5c6d5257067c969fcf7f875e6ad9ad3143e3025f8c391683b23cff9c24">transaction</a>.</p>
<p><img loading="lazy" src="/images/blockexplorer_faucet_tx.png" alt="Block Explorer Transaction"  />
</p>
<p>From this transaction, you can see what happens when you asked for 0.0001 bitcoin from the Testnet Faucet. It creates a transaction which sends the fund to the bitcoin address you specified. In the next part, I will show you how to generate your own bitcoin transaction to transfer some of the fund to a second address while sending the rest back to this one. This will simulate a purchase and getting change back. Stay tuned!</p>


  </div>

  <footer class="post-footer">
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2022 <a href="https://yugomike.github.io/">Michael Y. Han</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
