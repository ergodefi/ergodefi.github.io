<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Bitcoin Transactions - Part 2: Generating a P2PKH Transaction | Michael Y. Han</title>
<meta name="keywords" content="" />
<meta name="description" content="Before constructing a bitcoin transaction, let&rsquo;s first highlight the difference between a real life transaction and a bitcoin transaction. Knowing the difference will help you understand bitcoin better.
In real life, if you buy a pizza for $20.25 and you hand the cashier $25, you will get $4.75 back.
On the Bitcoin network, and assuming there is $100 in your account, it would look like this: you give all the cash inside your wallet to the cashier and then you take back $79.">
<meta name="author" content="">
<link rel="canonical" href="https://yugomike.github.io/posts/2-bitcoin-pt2-p2pkh-tx/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css" integrity="sha256-yIlj/i15RiAA/Q&#43;xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.4dcb3c4f38462f66c6b6137227726f5543cb934cca9788f041c087e374491df2.js" integrity="sha256-Tcs8TzhGL2bGthNyJ3JvVUPLk0zKl4jwQcCH43RJHfI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://yugomike.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://yugomike.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://yugomike.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://yugomike.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://yugomike.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Bitcoin Transactions - Part 2: Generating a P2PKH Transaction" />
<meta property="og:description" content="Before constructing a bitcoin transaction, let&rsquo;s first highlight the difference between a real life transaction and a bitcoin transaction. Knowing the difference will help you understand bitcoin better.
In real life, if you buy a pizza for $20.25 and you hand the cashier $25, you will get $4.75 back.
On the Bitcoin network, and assuming there is $100 in your account, it would look like this: you give all the cash inside your wallet to the cashier and then you take back $79." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://yugomike.github.io/posts/2-bitcoin-pt2-p2pkh-tx/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-02-19T20:56:53-08:00" />
<meta property="article:modified_time" content="2022-02-19T20:56:53-08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Bitcoin Transactions - Part 2: Generating a P2PKH Transaction"/>
<meta name="twitter:description" content="Before constructing a bitcoin transaction, let&rsquo;s first highlight the difference between a real life transaction and a bitcoin transaction. Knowing the difference will help you understand bitcoin better.
In real life, if you buy a pizza for $20.25 and you hand the cashier $25, you will get $4.75 back.
On the Bitcoin network, and assuming there is $100 in your account, it would look like this: you give all the cash inside your wallet to the cashier and then you take back $79."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://yugomike.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Bitcoin Transactions - Part 2: Generating a P2PKH Transaction",
      "item": "https://yugomike.github.io/posts/2-bitcoin-pt2-p2pkh-tx/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Bitcoin Transactions - Part 2: Generating a P2PKH Transaction",
  "name": "Bitcoin Transactions - Part 2: Generating a P2PKH Transaction",
  "description": "Before constructing a bitcoin transaction, let\u0026rsquo;s first highlight the difference between a real life transaction and a bitcoin transaction. Knowing the difference will help you understand bitcoin better.\nIn real life, if you buy a pizza for $20.25 and you hand the cashier $25, you will get $4.75 back.\nOn the Bitcoin network, and assuming there is $100 in your account, it would look like this: you give all the cash inside your wallet to the cashier and then you take back $79.",
  "keywords": [
    
  ],
  "articleBody": "Before constructing a bitcoin transaction, let’s first highlight the difference between a real life transaction and a bitcoin transaction. Knowing the difference will help you understand bitcoin better.\nIn real life, if you buy a pizza for $20.25 and you hand the cashier $25, you will get $4.75 back.\nOn the Bitcoin network, and assuming there is $100 in your account, it would look like this: you give all the cash inside your wallet to the cashier and then you take back $79.70, leaving $20.30. The cashier keeps $20.25 for the cost of the pizza, and the remaining $0.05 goes to the miner as transaction fee.\nPrimer on bitcoin transaction Unspent Transaction Outputs or UTXO You see in Bitcoin, there is no freeform representation of money like a $5 bill; instead, all funds are represented as unspent outputs from earlier transactions or UTXOs. Whenever you transact with bitcoins, you have to use the entire value associated with the an account. One or more of the outputs would go to recipients of the transaction as intended, and there is usually also one output that returns the extra “change” back to one of your own accounts.\nWhat happens if there’s not enough funds in an address? You would simply add additional inputs, which would in effect consolidate funds from multiple accounts.\nAt the end of the day, bitcoin transactions are just a different way of thinking about money. By altering the inputs and outputs based on the funds that you have access to, you can construct any transaction on the Bitcoin network.\nLocking and unlocking scripts As you can see, a bitcoin consists primarily consists of inputs and outputs. The inputs are essentially outputs from earlier transactions that are will be spent if the transaction is successful. And the outputs are the UTXOs, unspent transaction outputs available for a future transaction.\nTo keep the UTXOs secure, so that the intended recipient has to demonstrate they have the private key, Bitcoin uses a clever locking and unlocking scripts using digital signature (the elliptical curve variety).\nThe way it works is that when the transaction outputs are created, they come with a locking script that locks the UTXO so that only the person possessing the right private key can solve the algorithmic puzzle. This puzzle is created using Bitcoin’s own scripting language, called Script.\nWhen you create the transaction that consumes the UTXO, you use your private key to sign the transaction to create a digital signature (known as script_sig). The script_sig is encoded along with the input. If you use the correct private key to create the digital signature, you will solve the puzzle, thereby unlocking the UTXO for consumption. If you used the wrong private key, the puzzle fails and the transaction is nullified.\nThere is a lot of math in the verification of the digital signature. If you want to learn the math, I recommend reading Chapter 6 of Andreas Antonopoulos’ excellent book, Mastering Bitcoin.\nIn Part 3, we will write the Python code to generate and verify the digital signature. But before we get to the digital signature, we need to generate all the other components of a transaction. Let’s do this now.\nIt’s coding time! Now that we have some bitcoins and learned a bit about how transaction works, let’s go ahead and create our own transaction! We are going to create one of the most common transactions (in Bitcoin and real life), which is paying for something and getting some change back.\nThis is part 2 of a multi-part deep dive into bitcoin transaction. If you want to follow along, you should start with Part 1. Alternatively, you can clone the code from Part 1 using the command below.\ngit clone -b 1-wallet-address https://github.com/yugomike/btc-deepdive.git Generating the second identity First, we’ll need a second account (i.e. a new set of private and public keys) so that we can transfer the bitcoin from one account to another and observe the entire process. We can do this easily using the functionality we have already seen in Part 1, made available by helper.py.\n# identity 2  # ======================== secret_key2 = int.from_bytes(b'another secret identity two', 'big') # for reproducibility  assert 1  secret_key2  bitcoin_gen.n public_key2 = secret_key2 * G public_key2_compressed = PublicKey.from_point(public_key2).encode(compressed=True, hash160=False).hex() public_key_hash2 = PublicKey.from_point(public_key2).encode(compressed=True, hash160=True).hex() bitcoin_address2 = PublicKey.from_point(public_key2).address(net='test', compressed=True)  print(\"Bitcoin Identity #2\") print(\"* Secret (Private) Key:\", secret_key2) print(\"* Public key (uncompressed):\", (public_key2.x, public_key2.y)) print(\"* public key (compressed):\", public_key2_compressed) print(\"* Public key hash:\", public_key_hash2) print(\"* Bitcoin address:\", bitcoin_address2) Bitcoin Identity #2 * Secret (Private) Key: 40080948312511263619633009066092429669818823132623907411220264815 * Public key (uncompressed): (110398465478409316276920527699961004613373518058286253761163568467326599764908, 27581862894942929806511524173629706827067517406769995130296969522417828343338) * public key (compressed): 02f413512fca28fd30175ac631e3d5836dc0caac14d28236bacad57a9db7b11bac * Public key hash: 00f6739d5e8b4017a9eebe413249ed3949e65e24 * Bitcoin address: mfc3Xp6SfPZq2AfgXcVWRoZzWrqjZQtCrp Generating the inputs and output (TxIn and TxOut) objects Second, we need to generate the inputs and outputs (known as TxIn and TxOut respectively). We also need a Script object to store the locking and unlocking scripts, which are used in the locking and unlocking of the UTXO. Finally, we will construct the transaction (Tx) itself. Again, I have written the functionality in helper.py, so we can simply focus on understanding the process.\nfrom helper import TxIn, TxOut, Script, Tx  # transaction input #1  tx_in = TxIn(  prev_tx = bytes.fromhex('6707af5c6d5257067c969fcf7f875e6ad9ad3143e3025f8c391683b23cff9c24'),  prev_index = 1, # the 2nd output   script_sig = None, # signature to be inserted later   sequence = 0xffffffff, # almost never used and default to 0xffffffff ) Now let’s construct the transaction input. There is just 1 input, which is the funds we received from the Testnet Faucet transaction from Part 1.\nThat was a transaction with its own inputs and outputs, and one of its outputs was 0.0001 BTC sent to our public hey kash address. That was an example of an UTXO, and we are now going to spent it in the transaction we are creating.\nTo identify this input, we reference the previous transaction’s address (in the form of the public key hash) and the the index of that output (1 is he index as it indicates it was the second output). You don’t have to specify the actual value of the input, as Bitcoin can simply look up that previous transaction for the output’s value.\nWe also need to generate the digital signature (script_sig) used to unlock the UTXO. However, we cannot generate this yet, as it involves signing the entire transaction, which we are still constructing. We will come back to this later.\nFinally, every input also contains a sequence. It is not a feature currently being used, and this is indicated by the Bitcoin protocol as 0xffffffff.\nTransaction Outputs We will create 2 outputs, and this means we need 2 instances of TxOut. Unlike with input, we have to specify the actual amount for each output. Note that the amount is stored in the smallest unit of bitcoin, the satoshi, and 1 bitcoin = 100,000,000 sats. The transaction fee paid to the miner is not explicitly stated in the transaction. It is simply the difference between the sum of inputs and outputs.\n# transaction output #1 tx_out1 = TxOut(  amount = 75000, )  # transaction output #2 tx_out2 = TxOut(  amount = 22000, )  # 75000 + 22000 = 97000, which means 3000 sats are paid to the miner as transaction fee  We also have to create the locking script (or script_pubkey) for each output. The reference to pubkey refers to the public key hash. Each output is constructed so that it can only be unlocked by the person holding the private key for that public key hash. Recall the one-way relationships: private key creates the public key; and the public key creates the public key hash.\nThis means:\n as output 1 is being transferred to identity #2, its script_pubkey must include the public key hash for identity #2 as output 2 is transferred back to identity #1, its script_pubkey must include the public key hash for identity #1  output1_pkh = PublicKey.from_point(public_key2).encode(compressed=True, hash160=True) output2_pkh = PublicKey.from_point(public_key).encode(compressed=True, hash160=True)  # 118, 169, 136 and 172 are op_codes. # Refer to https://en.bitcoin.it/wiki/Script for more info output1_script = Script([118, 169, output1_pkh, 136, 172]) output2_script = Script([118, 169, output2_pkh, 136, 172])  output1_script.encode().hex() # output 1 in hex: 1976a91400f6739d5e8b4017a9eebe413249ed3949e65e2488ac output2_script.encode().hex() # output 2 in hex: 1976a91400f6739d5e8b4017a9eebe413249ed3949e65e2488ac  tx_out1.script_pubkey = output1_script # adding script_pubkey to output 1 tx_out2.script_pubkey = output2_script # adding script_pubkey to output 2 The placeholder for script_sig So far, we have created 2 identities, the input and outputs, and the locking scripts for the outputs, known as script_pubkey.\nThe final piece of puzzle we need to is the unlocking script, or the script_sig. The unlocking script has 2 parts: (1) the digital signature; and (2) the unhashed public key.\nWe generated the public key in Part 1, and now must generate the digital signature. But, there is a problem.\nYou see, the digital signature is generated by signing the hash of the entire transaction, which we are still building. So it seems we have a catch 22 on our hands. How can we get generate the digital signature when it requires the entire transaction to do it?\nFortunately, the Bitcoin protocol has a rule that solves our issue. It requires that we replace the script_sig (which we don’t have) with the script_pubkey from the previous transaction’s corresponding output (which we can find).\nWhat is the script_pubkey from the previous transaction? You can find it by going back to the previous transaction. With the op_codes expressed, it looks like the highlighted below.\nStaying true to the nature of this series, we are going to recreate it a more elementary format.\n# retrieve previous transaction output public key hash  public_key_hash = PublicKey.from_point(public_key).encode(compressed=True, hash160=True)  # constructing the previous tx locking script  prev_tx_script_pubkey = Script([118, 169, public_key_hash, 136, 172])  # adding the locking script as placeholder for input digital signature tx_in.prev_tx_script_pubkey = prev_tx_script_pubkey  print(\"Previous tx locking script:\", prev_tx_script_pubkey.encode().hex()) Previous tx locking script: 1976a914363bb1ef1d8791bdbd7e7492ef91decc1eb7295d88ac  Constructing the transaction (without digital signature) Now we have everything to finally construct the transaction! First, let’s import the transaction object (Tx) from helper.py. We will be storing all the ingredients inside this object, and use its encode() function to create the message for signing.\ntx = Tx(  version = 1, # currently just version 1 exists  tx_ins = [tx_in],  tx_outs = [tx_out1, tx_out2],  locktime = 0, ) # sig_index 0 means crafting digital signature for a specific input index  message = tx.encode(sig_index = 0) print(\"Message for signing: \", message.hex()) Message for signing: 0100000001249cff3cb28316398c5f02e34331add96a5e877fcf9f967c0657526d5caf0767010000001976a914363bb1ef1d8791bdbd7e7492ef91decc1eb7295d88acffffffff02f8240100000000001976a91400f6739d5e8b4017a9eebe413249ed3949e65e2488acf0550000000000001976a914363bb1ef1d8791bdbd7e7492ef91decc1eb7295d88ac0000000001000000\nThat’s it for Part 2. I was hoping to cover up to the generation of the digital signature, but it is getting too long. So instead, we will pick up from where we left off and generate the digital signature in the next part. We will then finally create the final transaction and propagate it to the Bitcoin network (Testnet). Stay tuned!\n",
  "wordCount" : "1792",
  "inLanguage": "en",
  "datePublished": "2022-02-19T20:56:53-08:00",
  "dateModified": "2022-02-19T20:56:53-08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://yugomike.github.io/posts/2-bitcoin-pt2-p2pkh-tx/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Michael Y. Han",
    "logo": {
      "@type": "ImageObject",
      "url": "https://yugomike.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://yugomike.github.io/" accesskey="h" title="Michael Y. Han (Alt + H)">Michael Y. Han</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Bitcoin Transactions - Part 2: Generating a P2PKH Transaction
    </h1>
    <div class="post-meta"><span title='2022-02-19 20:56:53 -0800 PST'>February 19, 2022</span>

</div>
  </header> 
  <div class="post-content"><p>Before constructing a bitcoin transaction, let&rsquo;s first highlight the difference between a real life transaction and a bitcoin transaction. Knowing the difference will help you understand bitcoin better.</p>
<p>In real life, if you buy a pizza for $20.25 and you hand the cashier $25, you will get $4.75 back.</p>
<p>On the Bitcoin network, and assuming there is $100 in your account, it would look like this: you give all the cash inside your wallet to the cashier and then you take back $79.70, leaving $20.30. The cashier keeps $20.25 for the cost of the pizza, and the remaining $0.05 goes to the miner as transaction fee.</p>
<h3 id="primer-on-bitcoin-transaction">Primer on bitcoin transaction<a hidden class="anchor" aria-hidden="true" href="#primer-on-bitcoin-transaction">#</a></h3>
<h4 id="unspent-transaction-outputs-or-utxo">Unspent Transaction Outputs or UTXO<a hidden class="anchor" aria-hidden="true" href="#unspent-transaction-outputs-or-utxo">#</a></h4>
<p>You see in Bitcoin, there is no freeform representation of money like a $5 bill; instead, all funds are represented as unspent outputs from earlier transactions or UTXOs. Whenever you transact with bitcoins, you have to use the entire value associated with the an account. One or more of the outputs would go to recipients of the transaction as intended, and there is usually also one output that returns the extra &ldquo;change&rdquo; back to one of your own accounts.</p>
<p>What happens if there&rsquo;s not enough funds in an address? You would simply add additional inputs, which would in effect consolidate funds from multiple accounts.</p>
<p>At the end of the day, bitcoin transactions are just a different way of thinking about money. By altering the inputs and outputs based on the funds that you have access to, you can construct any transaction on the Bitcoin network.</p>
<h4 id="locking-and-unlocking-scripts">Locking and unlocking scripts<a hidden class="anchor" aria-hidden="true" href="#locking-and-unlocking-scripts">#</a></h4>
<p>As you can see, a bitcoin consists primarily consists of inputs and outputs. The inputs are essentially outputs from earlier transactions  that are will be spent if the transaction is successful. And the outputs are the UTXOs, unspent transaction outputs available for a future transaction.</p>
<p>To keep the UTXOs secure, so that the intended recipient has to demonstrate they have the private key, Bitcoin uses a clever locking and unlocking scripts using digital signature (the elliptical curve variety).</p>
<p>The way it works is that when the transaction outputs are created, they come with a locking script that locks the UTXO so that only the person possessing the right private key can solve the algorithmic puzzle. This puzzle is created using Bitcoin&rsquo;s own scripting language, called Script.</p>
<p>When you create the transaction that consumes the UTXO, you use your private key to sign the transaction to create a digital signature (known as script_sig). The script_sig is encoded along with the input. If you use the correct private key to create the digital signature, you will solve the puzzle, thereby unlocking the UTXO for consumption. If you used the wrong private key, the puzzle fails and the transaction is nullified.</p>
<p>There is a lot of math in the verification of the digital signature. If you want to learn the math, I recommend reading <a href="https://github.com/bitcoinbook/bitcoinbook/blob/develop/ch06.asciidoc">Chapter 6</a> of Andreas Antonopoulos&rsquo; excellent book, Mastering Bitcoin.</p>
<p>In Part 3, we will write the Python code to generate and verify the digital signature. But before we get to the digital signature, we need to generate all the other components of a transaction. Let&rsquo;s do this now.</p>
<h3 id="its-coding-time">It&rsquo;s coding time!<a hidden class="anchor" aria-hidden="true" href="#its-coding-time">#</a></h3>
<p>Now that we have some bitcoins and learned a bit about how transaction works, let&rsquo;s go ahead and create our own transaction! We are going to create one of the most common transactions (in Bitcoin and real life), which is paying for something and getting some change back.</p>
<p>This is part 2 of a multi-part deep dive into bitcoin transaction. If you want to follow along, you should start with <a href="https://yugomike.github.io/posts/1-bitcoin-pt1-keys-and-addresses/">Part 1</a>. Alternatively, you can clone the code from Part 1 using the command below.</p>
<pre tabindex="0"><code>git clone -b 1-wallet-address https://github.com/yugomike/btc-deepdive.git
</code></pre><h4 id="generating-the-second-identity">Generating the second identity<a hidden class="anchor" aria-hidden="true" href="#generating-the-second-identity">#</a></h4>
<p>First, we&rsquo;ll need a second account (i.e. a new set of private and public keys) so that we can transfer the bitcoin from one account to another and observe the entire process.  We can do this easily using the functionality we have already seen in Part 1, made available by <em>helper.py</em>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># identity 2 </span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># ========================</span>
</span></span><span style="display:flex;"><span>secret_key2 <span style="color:#f92672">=</span> int<span style="color:#f92672">.</span>from_bytes(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;another secret identity two&#39;</span>, <span style="color:#e6db74">&#39;big&#39;</span>) <span style="color:#75715e"># for reproducibility </span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">assert</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;=</span> secret_key2 <span style="color:#f92672">&lt;</span> bitcoin_gen<span style="color:#f92672">.</span>n
</span></span><span style="display:flex;"><span>public_key2 <span style="color:#f92672">=</span> secret_key2 <span style="color:#f92672">*</span> G
</span></span><span style="display:flex;"><span>public_key2_compressed <span style="color:#f92672">=</span> PublicKey<span style="color:#f92672">.</span>from_point(public_key2)<span style="color:#f92672">.</span>encode(compressed<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>, hash160<span style="color:#f92672">=</span><span style="color:#66d9ef">False</span>)<span style="color:#f92672">.</span>hex()
</span></span><span style="display:flex;"><span>public_key_hash2 <span style="color:#f92672">=</span> PublicKey<span style="color:#f92672">.</span>from_point(public_key2)<span style="color:#f92672">.</span>encode(compressed<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>, hash160<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>)<span style="color:#f92672">.</span>hex()
</span></span><span style="display:flex;"><span>bitcoin_address2 <span style="color:#f92672">=</span> PublicKey<span style="color:#f92672">.</span>from_point(public_key2)<span style="color:#f92672">.</span>address(net<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;test&#39;</span>, compressed<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;Bitcoin Identity #2&#34;</span>)
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;* Secret (Private) Key:&#34;</span>, secret_key2)
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;* Public key (uncompressed):&#34;</span>, (public_key2<span style="color:#f92672">.</span>x, public_key2<span style="color:#f92672">.</span>y))
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;* public key (compressed):&#34;</span>, public_key2_compressed) 
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;* Public key hash:&#34;</span>, public_key_hash2) 
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;* Bitcoin address:&#34;</span>, bitcoin_address2)
</span></span></code></pre></div><pre tabindex="0"><code class="language-output" data-lang="output">Bitcoin Identity #2
* Secret (Private) Key: 40080948312511263619633009066092429669818823132623907411220264815
* Public key (uncompressed): (110398465478409316276920527699961004613373518058286253761163568467326599764908, 27581862894942929806511524173629706827067517406769995130296969522417828343338)
* public key (compressed): 02f413512fca28fd30175ac631e3d5836dc0caac14d28236bacad57a9db7b11bac
* Public key hash: 00f6739d5e8b4017a9eebe413249ed3949e65e24
* Bitcoin address: mfc3Xp6SfPZq2AfgXcVWRoZzWrqjZQtCrp
</code></pre><h4 id="generating-the--inputs-and-output-txin-and-txout-objects">Generating the  inputs and output (TxIn and TxOut) objects<a hidden class="anchor" aria-hidden="true" href="#generating-the--inputs-and-output-txin-and-txout-objects">#</a></h4>
<p>Second, we need to generate the inputs and outputs (known as TxIn and TxOut respectively). We also need a Script object to store the locking and unlocking scripts, which are used in the locking and unlocking of the UTXO. Finally, we will construct the transaction (Tx) itself. Again, I have written the functionality in <em>helper.py</em>, so we can simply focus on understanding the process.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">from</span> helper <span style="color:#f92672">import</span> TxIn, TxOut, Script, Tx
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># transaction input #1 </span>
</span></span><span style="display:flex;"><span>tx_in <span style="color:#f92672">=</span> TxIn(
</span></span><span style="display:flex;"><span>    prev_tx <span style="color:#f92672">=</span> bytes<span style="color:#f92672">.</span>fromhex(<span style="color:#e6db74">&#39;6707af5c6d5257067c969fcf7f875e6ad9ad3143e3025f8c391683b23cff9c24&#39;</span>), 
</span></span><span style="display:flex;"><span>    prev_index <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>, <span style="color:#75715e"># the 2nd output </span>
</span></span><span style="display:flex;"><span>    script_sig <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>, <span style="color:#75715e"># signature to be inserted later </span>
</span></span><span style="display:flex;"><span>    sequence <span style="color:#f92672">=</span> <span style="color:#ae81ff">0xffffffff</span>, <span style="color:#75715e"># almost never used and default to 0xffffffff</span>
</span></span><span style="display:flex;"><span>)
</span></span></code></pre></div><p>Now let&rsquo;s construct the transaction input. There is just 1 input, which is the funds we received from the Testnet Faucet transaction from <a href="https://yugomike.github.io/posts/1-bitcoin-pt1-keys-and-addresses/">Part 1</a>.</p>
<p>That was a transaction with its own inputs and outputs, and one of its outputs was 0.0001 BTC sent to our public hey kash address. That was an example of an UTXO, and we are now going to spent it in the transaction we are creating.</p>
<p>To identify this input, we reference the previous transaction&rsquo;s address (in the form of the public key hash) and the the index of that output (1 is he index as it indicates it was the second output). You don&rsquo;t have to specify the actual value of the input, as Bitcoin can simply look up that previous transaction for the output&rsquo;s value.</p>
<p>We also need to generate the digital signature (script_sig) used to unlock the UTXO. However, we cannot generate this yet, as it involves signing the entire transaction, which we are still constructing. We will come back to this later.</p>
<p>Finally, every input also contains a sequence. It is not a feature currently being used, and this is indicated by the Bitcoin protocol as 0xffffffff.</p>
<h4 id="transaction-outputs">Transaction Outputs<a hidden class="anchor" aria-hidden="true" href="#transaction-outputs">#</a></h4>
<p>We will create 2 outputs, and this means we need 2 instances of TxOut. Unlike with input, we have to specify the actual amount for each output. Note that the amount is stored in the smallest unit of bitcoin, the satoshi, and 1 bitcoin = 100,000,000 sats. The transaction fee paid to the miner is not explicitly stated in the transaction. It is simply the difference between the sum of inputs and outputs.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># transaction output #1</span>
</span></span><span style="display:flex;"><span>tx_out1 <span style="color:#f92672">=</span> TxOut(
</span></span><span style="display:flex;"><span>    amount <span style="color:#f92672">=</span> <span style="color:#ae81ff">75000</span>,
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># transaction output #2</span>
</span></span><span style="display:flex;"><span>tx_out2 <span style="color:#f92672">=</span> TxOut(
</span></span><span style="display:flex;"><span>    amount <span style="color:#f92672">=</span> <span style="color:#ae81ff">22000</span>,
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 75000 + 22000 = 97000, which means 3000 sats are paid to the miner as transaction fee </span>
</span></span></code></pre></div><p>We also have to create the locking script (or script_pubkey) for each output. The reference to pubkey refers to the public key hash. Each output is constructed so that it can only be unlocked by the person holding the private key for that public key hash. Recall the one-way relationships: private key creates the public key; and the public key creates the public key hash.</p>
<p>This means:</p>
<ul>
<li>as output 1 is being transferred to identity #2, its script_pubkey must include the public key hash for identity #2</li>
<li>as output 2 is transferred back to identity #1, its script_pubkey must include the public key hash for identity #1</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>output1_pkh <span style="color:#f92672">=</span> PublicKey<span style="color:#f92672">.</span>from_point(public_key2)<span style="color:#f92672">.</span>encode(compressed<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>, hash160<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>)  
</span></span><span style="display:flex;"><span>output2_pkh <span style="color:#f92672">=</span> PublicKey<span style="color:#f92672">.</span>from_point(public_key)<span style="color:#f92672">.</span>encode(compressed<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>, hash160<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 118, 169, 136 and 172 are op_codes. # Refer to https://en.bitcoin.it/wiki/Script for more info</span>
</span></span><span style="display:flex;"><span>output1_script <span style="color:#f92672">=</span> Script([<span style="color:#ae81ff">118</span>, <span style="color:#ae81ff">169</span>, output1_pkh, <span style="color:#ae81ff">136</span>, <span style="color:#ae81ff">172</span>])
</span></span><span style="display:flex;"><span>output2_script <span style="color:#f92672">=</span> Script([<span style="color:#ae81ff">118</span>, <span style="color:#ae81ff">169</span>, output2_pkh, <span style="color:#ae81ff">136</span>, <span style="color:#ae81ff">172</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>output1_script<span style="color:#f92672">.</span>encode()<span style="color:#f92672">.</span>hex() <span style="color:#75715e"># output 1 in hex: 1976a91400f6739d5e8b4017a9eebe413249ed3949e65e2488ac</span>
</span></span><span style="display:flex;"><span>output2_script<span style="color:#f92672">.</span>encode()<span style="color:#f92672">.</span>hex() <span style="color:#75715e"># output 2 in hex: 1976a91400f6739d5e8b4017a9eebe413249ed3949e65e2488ac</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>tx_out1<span style="color:#f92672">.</span>script_pubkey <span style="color:#f92672">=</span> output1_script <span style="color:#75715e"># adding script_pubkey to output 1</span>
</span></span><span style="display:flex;"><span>tx_out2<span style="color:#f92672">.</span>script_pubkey <span style="color:#f92672">=</span> output2_script <span style="color:#75715e"># adding script_pubkey to output 2</span>
</span></span></code></pre></div><h4 id="the-placeholder-for-script_sig">The placeholder for script_sig<a hidden class="anchor" aria-hidden="true" href="#the-placeholder-for-script_sig">#</a></h4>
<p>So far, we have created 2 identities, the input and outputs, and the locking scripts for the outputs, known as script_pubkey.</p>
<p>The final piece of puzzle we need to is the unlocking script, or the script_sig. The unlocking script has 2 parts: (1) the digital signature; and (2) the unhashed public key.</p>
<p>We generated the public key in Part 1, and now must generate the digital signature. But, there is a problem.</p>
<p>You see, the digital signature is generated by signing the hash of the entire transaction, which we are still building. So it seems we have a catch 22 on our hands. How can we get generate the digital signature when it requires the entire transaction to do it?</p>
<p>Fortunately, the Bitcoin protocol has a rule that solves our issue. It requires that we replace the script_sig (which we don&rsquo;t have) with the script_pubkey from the previous transaction&rsquo;s corresponding output (which we can find).</p>
<p>What is the script_pubkey from the previous transaction? You can find it by going back to the <a href="https://www.blockchain.com/btc-testnet/tx/6707af5c6d5257067c969fcf7f875e6ad9ad3143e3025f8c391683b23cff9c24">previous transaction</a>. With the op_codes expressed, it looks like the highlighted below.</p>
<p><img loading="lazy" src="/images/prev_tx_script_pubkey.png" alt="img"  />
</p>
<p>Staying true to the nature of this series, we are going to recreate it a more elementary format.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># retrieve previous transaction output public key hash </span>
</span></span><span style="display:flex;"><span>public_key_hash <span style="color:#f92672">=</span> PublicKey<span style="color:#f92672">.</span>from_point(public_key)<span style="color:#f92672">.</span>encode(compressed<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>, hash160<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># constructing the previous tx locking script </span>
</span></span><span style="display:flex;"><span>prev_tx_script_pubkey <span style="color:#f92672">=</span> Script([<span style="color:#ae81ff">118</span>, <span style="color:#ae81ff">169</span>, public_key_hash, <span style="color:#ae81ff">136</span>, <span style="color:#ae81ff">172</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># adding the locking script as placeholder for input digital signature</span>
</span></span><span style="display:flex;"><span>tx_in<span style="color:#f92672">.</span>prev_tx_script_pubkey <span style="color:#f92672">=</span> prev_tx_script_pubkey 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;Previous tx locking script:&#34;</span>, prev_tx_script_pubkey<span style="color:#f92672">.</span>encode()<span style="color:#f92672">.</span>hex())
</span></span></code></pre></div><pre><code>Previous tx locking script: 1976a914363bb1ef1d8791bdbd7e7492ef91decc1eb7295d88ac
</code></pre>
<h4 id="constructing-the-transaction-without-digital-signature">Constructing the transaction (without digital signature)<a hidden class="anchor" aria-hidden="true" href="#constructing-the-transaction-without-digital-signature">#</a></h4>
<p>Now we have everything to finally construct the transaction! First, let&rsquo;s import the transaction object (Tx) from <em>helper.py</em>. We will be storing all the ingredients inside this object, and use its encode() function to create the message for signing.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>tx <span style="color:#f92672">=</span> Tx(
</span></span><span style="display:flex;"><span>    version <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>, <span style="color:#75715e"># currently just version 1 exists</span>
</span></span><span style="display:flex;"><span>    tx_ins <span style="color:#f92672">=</span> [tx_in],
</span></span><span style="display:flex;"><span>    tx_outs <span style="color:#f92672">=</span> [tx_out1, tx_out2],
</span></span><span style="display:flex;"><span>    locktime <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e"># sig_index 0 means crafting digital signature for a specific input index </span>
</span></span><span style="display:flex;"><span>message <span style="color:#f92672">=</span> tx<span style="color:#f92672">.</span>encode(sig_index <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>) 
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;Message for signing: &#34;</span>, message<span style="color:#f92672">.</span>hex())
</span></span></code></pre></div><p><code>Message for signing:  0100000001249cff3cb28316398c5f02e34331add96a5e877fcf9f967c0657526d5caf0767010000001976a914363bb1ef1d8791bdbd7e7492ef91decc1eb7295d88acffffffff02f8240100000000001976a91400f6739d5e8b4017a9eebe413249ed3949e65e2488acf0550000000000001976a914363bb1ef1d8791bdbd7e7492ef91decc1eb7295d88ac0000000001000000</code></p>
<p>That&rsquo;s it for Part 2. I was hoping to cover up to the generation of the digital signature, but it is getting too long. So instead, we will pick up from where we left off and generate the digital signature in the next part. We will then finally create the final transaction and propagate it to the Bitcoin network (Testnet). Stay tuned!</p>


  </div>

  <footer class="post-footer">
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2022 <a href="https://yugomike.github.io/">Michael Y. Han</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
